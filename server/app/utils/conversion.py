################################################################################
# Filename: conversion.py
# Purpose:  Perform audio processing and conversion tasks to MIDI.
# Author:   Darren Seubert
#
# Description:
# This file contains functions for audio processing tasks, including conversion
# of audio files to MIDI format. It includes helper functions for audio file
# conversion to wav file, frequency segmentation, and MIDI file generation.
#
# Usage (Optional):
# User can use the provided functions to convert audio files to MIDI format.
# Ensure that the required dependencies, such as pydub, librosa, numpy, scipy,
# and mido, are installed in user's Python environment.
#
# Notes:
# - This file supports audio files with extensions mp3, m4a, and wav.
# - Ensure that the audio files contain a single melody line for accurate
#   MIDI conversion.
# - The MIDI files generated by this file will contain MIDI note messages
#   corresponding to the detected pitch and rhythm of the input audio.
#
###############################################################################

from basic_pitch.inference import predict
import os
import subprocess

SUPPORTED_EXTENSIONS = {"m4a", "mp3", "wav"}
MIDI_OUTPUT_DIR = "./app/utils/midi_output"


def convert_webm_to_mp3(input_file, output_file):
    """
    Converts a WEBM audio file to MP3 format using ffmpeg.

    Args:
        input_file (str): Path to the input WEBM file.
        output_file (str): Path to save the converted MP3 file.
    """
    # Command to convert the WEBM file to MP3
    command = [
        "ffmpeg",
        "-i",
        input_file,
        "-vn",
        "-ab",
        "192k",
        "-ar",
        "44100",
        "-y",
        output_file,
    ]

    # Run the command through the subprocess module
    try:
        subprocess.run(command, check=True)
        print("Conversion completed successfully.")
    except subprocess.CalledProcessError:
        print("An error occurred during conversion.")


def is_webm_file(file_path: str) -> bool:
    """
    Checks if the given file is a WEBM file based on its extension.

    Args:
        file_path (str): Path to the file to be checked.

    Returns:
        bool: True if the file is a WEBM file, False otherwise.
    """
    return os.path.splitext(file_path)[1].lower() == ".webm"


def replace_extension(file_path: str, new_ext: str) -> str:
    """
    Replaces the file extension of the given file path with a new extension.

    Args:
        file_path (str): Original file path.
        new_ext (str): New file extension (with or without leading dot).

    Returns:
        str: File path with the new extension.
    """
    root, _ = os.path.splitext(file_path)
    new_ext = new_ext if new_ext.startswith(".") else f".{new_ext}"
    return root + new_ext


def validate_audio_file(file_path: str) -> str | None:
    """
    Validates an audio file for MIDI conversion.

    - Converts WEBM to MP3 if necessary.
    - Validates supported extensions.

    Args:
        file_path: Path to the original audio file.

    Returns:
        Path to the prepared audio file (possibly converted), or None if unsupported.
    """
    # Convert WEBM â†’ MP3 if needed
    if is_webm_file(file_path):
        mp3_path = replace_extension(file_path, "mp3")
        convert_webm_to_mp3(file_path, mp3_path)
        file_path = mp3_path

    # Validate extension after potential conversion
    _, ext = os.path.splitext(file_path)
    if ext.lower().lstrip(".") not in SUPPORTED_EXTENSIONS:
        print(f"Unsupported audio format: {ext}")
        return None

    return file_path


def convert_to_midi(input_audio_path: str) -> str | None:
    """
    Convert an audio file to MIDI using Basic Pitch.

    Args:
        input_audio_path: Path to input audio file.

    Returns:
        Path to generated MIDI file, or None if unsupported.
    """
    # Prepare audio file (convert if needed, validate extension)
    input_audio_path = validate_audio_file(input_audio_path)
    if not input_audio_path:
        return None

    # Extract base name for MIDI file
    base_name = os.path.splitext(os.path.basename(input_audio_path))[0]

    # Run pitch prediction
    _, midi_data, _ = predict(input_audio_path)

    # Save MIDI file
    midi_path = os.path.join(MIDI_OUTPUT_DIR, base_name + ".mid")
    midi_data.write(midi_path)

    return midi_path
